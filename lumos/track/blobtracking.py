"""Blob detection and tracking."""

from math import sqrt, hypot
import numpy as np
import cv2

from ..util import Enum
from ..base import DependentFrameProcessor
from ..filter.colorfilter import ColorFilterProcessor

class Blob:
  """Represents a colored blob, with associated properties."""
  
  # Weights used in summing up blob differences
  areaWeight = 0.5
  hypotWeight = 0.3
  centerWeight = 0.2
  
  colorBlue = (255, 0, 0)
  colorDarkBlue = (128, 64, 64)
  colorGreen = (0, 255, 0)
  colorDarkGreen = (64, 128, 64)
  colorRed = (0, 0, 255)
  colorDarkRed = (64, 64, 128)
  colorMagenta = (255, 0, 255)
  
  def __init__(self, contour, tag, firstSeen, lastSeen, area=None):
    self.contour = contour
    self.tag = tag
    self.firstSeen = firstSeen
    self.lastSeen = lastSeen
    self.area = area if area is not None else cv2.contourArea(contour)  # area should've been pre-computed
    self.bbox = cv2.boundingRect(contour)
    self.rect = cv2.minAreaRect(contour)
    self.center = (int(self.rect[0][0]), int(self.rect[0][1]))  # int precision is all we need
    self.size = self.rect[1]
    self.angle = self.rect[2]
    
    if self.size[0] > self.size[1]:
      self.size = (self.size[1], self.size[0])  # force it to be tall and narrow (for convenience)
      self.angle = (self.angle + 90) % 360
    
    self.hypot = hypot(self.size[0], self.size[1])
    self.aspect = self.size[0] / self.size[1]
    self.rectArea = self.size[0] * self.size[1]
    self.density = self.area / self.rectArea
    self.lastCenter = None  # filled in when a matching blob is found from last frame
    self.active = True
    
    # TODO define other properties, including color
  
  def diff(self, other):
    """Return the difference between this blob and other as a single numeric value."""
    selfBigger = self.hypot >= other.hypot
    areaDiff = abs(other.area - self.area) / (self.area if selfBigger else other.area)
    hypotDiff = abs(other.hypot - self.hypot) / (self.hypot if selfBigger else other.hypot)
    #sizeDiff = hypot(other.size[0] - self.size[0], other.size[1] - self.size[1]) / (self.hypot if selfBigger else other.hypot)
    centerDiff = hypot(other.center[0] - self.center[0], other.center[1] - self.center[1]) / (self.hypot if selfBigger else other.hypot)
    # TODO Use Hu moments? color?
    return self.areaWeight * areaDiff + self.hypotWeight * hypotDiff + self.centerWeight * centerDiff
  
  def draw(self, imageOut, drawDetail=False):
    if drawDetail:
      # Contours
      #cv2.drawContours(imageOut, [self.contour], 0, self.colorGreen if self.active else self.colorDarkGreen, 2)
      
      # Motion trace
      if self.active and self.lastCenter is not None:  # if a lastCenter is available
        if hypot(self.center[0] - self.lastCenter[0], self.center[1] - self.lastCenter[1]) < 10:
          cv2.circle(imageOut, self.center, 10, self.colorMagenta, 2)  # if too close, just draw a circle
        else:
          cv2.line(imageOut, self.center, self.lastCenter, self.colorMagenta, 2)  # else draw a line
      
      # Rotated rectangle
      rectBox = np.int_(cv.BoxPoints(self.rect))
      #print rectBox  # [debug]
      cv2.drawContours(imageOut, [rectBox], 0, self.colorBlue if self.active else self.colorDarkBlue, 2)
      #cv2.polylines(imageOut, [rectBox], True, self.colorBlue if self.active else self.colorDarkBlue, 2)  # alt. method; TODO test which one of polylines and drawContours is faster (?)
    else:
      # Just the bounding box
      cv2.rectangle(imageOut, (self.bbox[0], self.bbox[1]), (self.bbox[0] + self.bbox[2], self.bbox[1] + self.bbox[3]), self.colorBlue if self.active else self.colorDarkBlue, 2)
  
  def __str__(self):
    return ("" if self.active else "~") + self.tag
  
  def detail(self):
    return ("" if self.active else "~") + "{tag} - area: {area}, density: {density:.2f}, center: {center}, hypot: {hypot:.2f}, angle: {angle:.2f}, aspect: {aspect:.3f}".format(tag=self.tag, area=self.area, density=self.density, center=self.center, hypot=self.hypot, angle=self.angle, aspect=self.aspect)


class BlobTracker(DependentFrameProcessor):
  """Detects and tracks colored blobs using masks generated by a color filter, if available."""
  
  State = Enum(['INIT', 'LIVE'])
  minBlobArea = 5000
  maxBlobArea = 50000
  minBlobDensity = 0.67  # fraction of pixels within rectangular area that are filled
  maxBlobDiff = 0.25
  maxBlobAge = 1.0  # secs; max duration for which unseen blobs are kept around for possible matches later
  
  def __init__(self, processorPool):
    DependentFrameProcessor.__init__(self, processorPool)
    self.colorFilterProcessor = processorPool.getProcessorByType(ColorFilterProcessor)  # keep a reference to a ColorFilterProcessor, if given
    self.state = self.State.INIT
  
  def initialize(self, imageIn, timeNow):
    self.image = imageIn
    self.imageSize = (self.image.shape[1], self.image.shape[0])  # (width, height)
    self.imageCenter = (self.imageSize[0] / 2, self.imageSize[1] / 2)  # (x, y)
    self.imageOut = None
    self.morphOpenKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    self.blobs = []
    self.lastBlobs = self.blobs
    self.state = self.State.LIVE
    self.active = True
  
  def process(self, imageIn, timeNow):
    self.image = imageIn
    if self.context.options.gui: self.imageOut = self.image.copy()
    
    self.blobs = []  # initialize blobs list - new blobs will be added here, those that match previous blobs will get updated
    
    # * If we have a ColorFilterProcessor and it is live
    if (self.colorFilterProcessor is not None) and (self.colorFilterProcessor.state == ColorFilterProcessor.State.LIVE):
      # ** For each available mask
      for maskName, mask in self.colorFilterProcessor.masks.iteritems():
        if maskName == "white": continue  # we're not interested in whites
        
        # *** Smooth out mask and remove noise
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, self.morphOpenKernel, iterations=2)
        if self.context.options.gui: cv2.imshow(maskName, mask)
        
        # *** Detect contours in mask
        contours, _ = cv2.findContours(mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        if len(contours) > 0:
          #self.logger.debug("[%.2f] %d %s contour(s)" % (timeNow, len(contours), maskName))  # report contours found
          #if self.context.options.gui and self.context.options.debug: cv2.drawContours(self.imageOut, contours, -1, (0, 255, 255))  # draw all contours found
          
          # **** Walk through list of contours
          for contour in contours:
            contour = contour.astype(np.int32)  # convert contours to 32-bit int for each individual contour [Pandaboard OpenCV bug workaround]
            
            # ***** Filter out ones that are too small or too big
            area = cv2.contourArea(contour)
            if area < self.minBlobArea or area > self.maxBlobArea: continue
            
            # ***** Create blob object and apply additional filter(s) on computed blob properties
            blob = Blob(contour=contour, tag=maskName, firstSeen=timeNow, lastSeen=timeNow, area=area)
            if blob.density < self.minBlobDensity: continue
            
            # ***** Add to blobs list, resolve with existing blob objects and update properties if a match is found
            self.blobs.append(blob)
            
            minDiff = self.maxBlobDiff  # difference has to be less than this to be a valid match
            matchingBlob = None
            for otherBlob in self.lastBlobs:
              if not blob.tag == otherBlob.tag: continue  # tag must match? TODO remove this constraint and compare actual colors
              diff = blob.diff(otherBlob)
              if diff < minDiff:
                minDiff = diff
                matchingBlob = otherBlob
            
            if matchingBlob is not None:
              blob.lastCenter = matchingBlob.center
              blob.firstSeen = matchingBlob.firstSeen
              matchingBlob.lastSeen = 0  # this will help identify old blobs correctly later
        
    # * Add back unmatched blobs from lastBlobs that are not too old, in the process purging old blobs
    for blob in self.lastBlobs:
      if blob.lastSeen == 0: continue  # already matched, skip
      if (timeNow - blob.lastSeen) <= self.maxBlobAge:
        blob.active = False
        self.blobs.append(blob)  # if this is a young blob (even though not seen in this frame), keep it around
    
    # * Draw, report blobs
    if len(self.blobs) > 0:
      self.logger.debug("[%.2f] %d blob(s): %s" % (timeNow, len(self.blobs), ", ".join([str(blob) for blob in self.blobs])))  # preceding ~ indicates blob is not active (i.e. not seen in this frame)
      if self.context.options.gui:
        for blob in self.blobs:
          #print blob.detail()  # [debug]
          blob.draw(self.imageOut, self.context.options.debug)  # if debug, draw rotated rects as well (requires some additional computation and drawing steps)
      
      centerBlob = self.getNearestBlob(minArea=self.maxBlobArea / 2)  # [debug] by default finds near center of image
      if centerBlob is not None: self.logger.info("[%.2f] Center blob: %s" % (timeNow, centerBlob))  # [debug]
      if self.context.options.gui and centerBlob is not None: cv2.putText(self.imageOut, centerBlob.tag, centerBlob.center, cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0), 2)  # [debug]
    
    # * Store current blobs for comparison in next iteration (frame)
    self.lastBlobs = self.blobs
    
    return True, self.imageOut
  
  def getBlobs(self, tag=None, activeOnly=True):  # activeOnly=False will get inactive blobs as well
    """Return a generator/list for blobs that match given tag (or all, if not given) and are active (as specified)."""
    if tag is not None:
      return (blob for blob in self.blobs if (blob.active or not activeOnly) and blob.tag == tag)
    elif activeOnly:
      return (blob for blob in self.blobs if blob.active)
    else:
      self.blobs
  
  def getBlob(self, tag=None, activeOnly=True, likeBlob=None):
    """Return a single blob most similar to likeBlob, looking only at matching tags (if given) and active ones (if specified)."""
    minDiff = self.maxBlobDiff
    matchingBlob = None
    for otherBlob in self.getBlobs(tag, activeOnly):
      #if (tag is not None and not tag == otherBlob.tag) or (activeOnly and not otherBlob.active): continue  # taken care of by getBlobs()
      if likeBlob is not None:
        diff = likeBlob.diff(otherBlob)
        if diff < minDiff:
          minDiff = diff
          matchingBlob = otherBlob
      else:
        matchingBlob = otherBlob  # no likeBlob specified, return the first one that matches tag
        break
    return matchingBlob
  
  def getNearestBlob(self, tag=None, activeOnly=True, point=None, maxDist=np.inf, minArea=minBlobArea):
    if point is None: point = self.imageCenter
    minDist = maxDist
    nearestBlob = None
    for blob in self.getBlobs(tag, activeOnly):
      dist = hypot(blob.center[0] - point[0], blob.center[1] - point[1])
      if dist < minDist:
        minDist = dist
        nearestBlob = blob
    return nearestBlob
